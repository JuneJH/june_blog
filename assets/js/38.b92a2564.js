(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{454:function(_,v,t){"use strict";t.r(v);var a=t(62),i=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"java基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java基础"}},[_._v("#")]),_._v(" Java基础")]),_._v(" "),t("blockquote",[t("p",[_._v("类和类之间的关系"),t("code",[_._v("is-a(继承 实现)")]),_._v(" "),t("code",[_._v("has-a(组合 聚合 关联)")]),_._v(" "),t("code",[_._v("use-a(need-a)(依赖)")])]),_._v(" "),t("p",[_._v("Java面向对象是大特性:继承 封装 多态 （抽象）")])]),_._v(" "),t("h2",{attrs:{id:"_1-java-特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-java-特性"}},[_._v("#")]),_._v(" 1. Java 特性")]),_._v(" "),t("ul",[t("li",[_._v("跨平台(JVM--Java Virtual Machine): 以前跨芯片,现在跨操作系统")]),_._v(" "),t("li",[_._v("面向对象")]),_._v(" "),t("li",[_._v("简单性")]),_._v(" "),t("li",[_._v("健壮性")]),_._v(" "),t("li",[_._v("多线程")]),_._v(" "),t("li",[_._v("大数据开发相关")])]),_._v(" "),t("h2",{attrs:{id:"_2-数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据类型"}},[_._v("#")]),_._v(" 2. 数据类型")]),_._v(" "),t("h3",{attrs:{id:"_1-基本数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本数据类型"}},[_._v("#")]),_._v(" 1. 基本数据类型")]),_._v(" "),t("ol",[t("li",[_._v("整型\n"),t("ul",[t("li",[_._v("byte: 字节型 8个bit 第一位为符号位 范围-2的7次方～2的7次方-1(0表示0这个数)")]),_._v(" "),t("li",[_._v("short: 2字节16bit")]),_._v(" "),t("li",[_._v("int: 4字节32bit")]),_._v(" "),t("li",[_._v("long: 8字节64bit")])])]),_._v(" "),t("li",[_._v("浮点型\n"),t("ul",[t("li",[_._v("float: 4字节32bit 首位表示符号，然后9个bit表示整数，后面小数")]),_._v(" "),t("li",[_._v("double: 8字节64bit 首位表示符号，然后19个表示整数，后面小数")])])]),_._v(" "),t("li",[_._v("字符型\n"),t("ul",[t("li",[_._v("char: 2字节16bit")])])]),_._v(" "),t("li",[_._v("布尔型\n"),t("ul",[t("li",[_._v("boolean 1bit ture false")])])])]),_._v(" "),t("h3",{attrs:{id:"_2-引用数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-引用数据类型"}},[_._v("#")]),_._v(" 2. 引用数据类型")]),_._v(" "),t("ol",[t("li",[_._v("数组 []")]),_._v(" "),t("li",[_._v("类/抽象类 class/abstract class")]),_._v(" "),t("li",[_._v("接口 interface")]),_._v(" "),t("li",[_._v("枚举 enum")]),_._v(" "),t("li",[_._v("注解 @interface")])]),_._v(" "),t("h3",{attrs:{id:"_3-常量和变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-常量和变量"}},[_._v("#")]),_._v(" 3. 常量和变量")]),_._v(" "),t("h4",{attrs:{id:"_1-常量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-常量"}},[_._v("#")]),_._v(" 1. 常量")]),_._v(" "),t("ol",[t("li",[_._v("常量指程序运行过程中不能再次改变的值.")]),_._v(" "),t("li",[_._v("基本类型的值固定不变")]),_._v(" "),t("li",[_._v("特殊的常量比如String")]),_._v(" "),t("li",[_._v("final 修饰的")])]),_._v(" "),t("h4",{attrs:{id:"_2-变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-变量"}},[_._v("#")]),_._v(" 2. 变量")]),_._v(" "),t("ol",[t("li",[_._v("变量指在程序运行过程可以改变的")]),_._v(" "),t("li",[_._v("变量指一个内存空间")]),_._v(" "),t("li",[_._v("创建变量必须指定数据类型，变量空间名字")]),_._v(" "),t("li",[_._v("变量空间只能存储一个内容(值或者引用)")]),_._v(" "),t("li",[_._v("变量空间内容可以改变")]),_._v(" "),t("li",[_._v("jvm 开辟一个空间")]),_._v(" "),t("li",[_._v("栈内存")]),_._v(" "),t("li",[_._v("堆内存")]),_._v(" "),t("li",[_._v("存储区 常量缓冲区，方法区，静态区")]),_._v(" "),t("li",[_._v("常量通常使用32bit（int）和64bit（double）存储")]),_._v(" "),t("li",[_._v("因此使用float a = 3.2F; long b = 3L;")])]),_._v(" "),t("h3",{attrs:{id:"_4-数据类型转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-数据类型转换"}},[_._v("#")]),_._v(" 4. 数据类型转换")]),_._v(" "),t("ol",[t("li",[_._v("基本数据类型之间分为强制和自动转换\n"),t("ul",[t("li",[_._v("强制转换可能会造成数据丢失，自动转换发生在同种数据类型且内存空间大于被转换空间")]),_._v(" "),t("li",[_._v("浮点型和整形转换，比较精确程度，所以整形可以自动转浮点型")]),_._v(" "),t("li",[_._v("字符与整形转换根据Unicode码")]),_._v(" "),t("li",[_._v("布尔值不能发生转换，布尔值的空间为1bit")]),_._v(" "),t("li",[_._v("运算符会自动提升数据类型，赋值运算符会自动转换数据类型截取")])])]),_._v(" "),t("li",[_._v("引用类型之间转换分为上转型、下转型")]),_._v(" "),t("li",[_._v("基本类型和引用类型转换需要借助包装类\n"),t("ul",[t("li",[_._v("Int--\x3e Integer char--\x3eCharacter long--\x3eLong float--\x3eFloat")])])])]),_._v(" "),t("h3",{attrs:{id:"_5-运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-运算"}},[_._v("#")]),_._v(" 5. 运算")]),_._v(" "),t("h4",{attrs:{id:"_1-算术运算符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-算术运算符"}},[_._v("#")]),_._v(" 1. 算术运算符")]),_._v(" "),t("ol",[t("li",[t("code",[_._v("+")]),_._v(","),t("code",[_._v("-")]),_._v(","),t("code",[_._v("*")]),_._v(","),t("code",[_._v("/,%")]),_._v(","),t("code",[_._v("++")]),_._v(","),t("code",[_._v("--")])]),_._v(" "),t("li",[_._v("会自动提升数据类型")])]),_._v(" "),t("h4",{attrs:{id:"_2-赋值运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-赋值运算"}},[_._v("#")]),_._v(" 2. 赋值运算")]),_._v(" "),t("ol",[t("li",[t("code",[_._v("=")]),_._v(","),t("code",[_._v("+=")])]),_._v(" "),t("li",[_._v("如果后面是常量会自动对数据进行转换，如果是表达式需要强制转换")])]),_._v(" "),t("h4",{attrs:{id:"_3-关系运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-关系运算"}},[_._v("#")]),_._v(" 3. 关系运算")]),_._v(" "),t("ol",[t("li",[t("code",[_._v(">")]),_._v(","),t("code",[_._v(">=")]),_._v(","),t("code",[_._v("<")]),_._v(","),t("code",[_._v("<=")]),_._v(","),t("code",[_._v("!=")]),_._v(","),t("code",[_._v("==")]),_._v(","),t("code",[_._v("Object instanceof Object")])])]),_._v(" "),t("h3",{attrs:{id:"_4-逻辑运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-逻辑运算"}},[_._v("#")]),_._v(" 4. 逻辑运算")]),_._v(" "),t("ol",[t("li",[_._v("&: 按位与")]),_._v(" "),t("li",[_._v("|: 按位或")]),_._v(" "),t("li",[_._v("^: 异或")]),_._v(" "),t("li",[_._v("!: 逻辑非")]),_._v(" "),t("li",[_._v("&&: 短路与\n"),t("ul",[t("li",[_._v("当第一个为false时才会发生短路，提高性能")])])]),_._v(" "),t("li",[_._v("||: 短路或")])]),_._v(" "),t("h4",{attrs:{id:"_5-位运算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-位运算"}},[_._v("#")]),_._v(" 5. 位运算")]),_._v(" "),t("ol",[t("li",[t("code",[_._v("&")]),_._v(": 按位与")]),_._v(" "),t("li",[t("code",[_._v("|")]),_._v(": 按位或")]),_._v(" "),t("li",[t("code",[_._v("^")]),_._v(": 按位异或")]),_._v(" "),t("li",[t("code",[_._v("~")]),_._v(": 按位取反")]),_._v(" "),t("li",[t("code",[_._v(">>")]),_._v(": 按位右移\n"),t("ul",[t("li",[_._v("相当于除以的2位移次幂的")]),_._v(" "),t("li",[_._v("负数保留符号位原来是什么就是什么")])])]),_._v(" "),t("li",[t("code",[_._v("<<")]),_._v(": 按位左移\n"),t("ul",[t("li",[_._v("相当于乘以的2位移次幂的")])])]),_._v(" "),t("li",[t("code",[_._v(">>>")]),_._v(": 按位右移(无符号)\n"),t("ul",[t("li",[_._v("不保留符号位，补填0")])])]),_._v(" "),t("li",[_._v("原码、补码、反码\n"),t("ul",[t("li",[_._v("正数的三个码是一样的")]),_._v(" "),t("li",[_._v("负数的反码是保持符号位不变其余位取反的")]),_._v(" "),t("li",[_._v("负数的补码是反码加一")]),_._v(" "),t("li",[_._v("计算机重存储的是补码")])])])]),_._v(" "),t("h2",{attrs:{id:"_3-语法结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-语法结构"}},[_._v("#")]),_._v(" 3. 语法结构")]),_._v(" "),t("h3",{attrs:{id:"_1-顺序结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-顺序结构"}},[_._v("#")]),_._v(" 1. 顺序结构")]),_._v(" "),t("h3",{attrs:{id:"_2-分支结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-分支结构"}},[_._v("#")]),_._v(" 2. 分支结构")]),_._v(" "),t("ul",[t("li",[_._v("if(){}else{}")]),_._v(" "),t("li",[_._v("if(){}else if(){}")]),_._v(" "),t("li",[_._v("switch(){case;default}")])]),_._v(" "),t("h3",{attrs:{id:"_3-循环结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-循环结构"}},[_._v("#")]),_._v(" 3. 循环结构")]),_._v(" "),t("ul",[t("li",[_._v("for(;😉{}")])]),_._v(" "),t("h4",{attrs:{id:"_4-转义字符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-转义字符"}},[_._v("#")]),_._v(" 4. 转义字符")]),_._v(" "),t("ul",[t("li",[_._v("\\n: 换行")]),_._v(" "),t("li",[_._v("\\t: 制表符")]),_._v(" "),t("li",[_._v("\\r: 回车")])]),_._v(" "),t("h2",{attrs:{id:"_4-内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-内存"}},[_._v("#")]),_._v(" 4. 内存")]),_._v(" "),t("ol",[t("li",[_._v("JVM: 在内存中开辟一块儿空间")]),_._v(" "),t("li",[_._v("JVM开辟的空间分为栈内存,堆内存,存储区(常量缓冲区,方法区,静态元素区)")]),_._v(" "),t("li",[_._v("classLoader(类加载器),会把JVM编译好的类文件映射至方法区")]),_._v(" "),t("li",[_._v("当new一个类时,会通过方法区的类文件映射作为模版创建一个对象")])]),_._v(" "),t("h2",{attrs:{id:"_5-修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-修饰符"}},[_._v("#")]),_._v(" 5. 修饰符")]),_._v(" "),t("h3",{attrs:{id:"_1-权限修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-权限修饰符"}},[_._v("#")]),_._v(" 1. 权限修饰符")]),_._v(" "),t("ul",[t("li",[_._v("public: 公共的权限最大")]),_._v(" "),t("li",[_._v("protected: 受保护的")]),_._v(" "),t("li",[_._v("默认不写: 默认")]),_._v(" "),t("li",[_._v("privete: 私有")])]),_._v(" "),t("h3",{attrs:{id:"_2-权限修饰符的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-权限修饰符的区别"}},[_._v("#")]),_._v(" 2 .权限修饰符的区别")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th"),_._v(" "),t("th",[_._v("本类")]),_._v(" "),t("th",[_._v("同包")]),_._v(" "),t("th",[_._v("子类")]),_._v(" "),t("th",[_._v("当前工程")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("public")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("✅")])]),_._v(" "),t("tr",[t("td",[_._v("protected")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("✅(在子类的内部访问)")]),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td",[_._v("默认不写")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td",[_._v("privete")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td"),_._v(" "),t("td"),_._v(" "),t("td")])])]),_._v(" "),t("h3",{attrs:{id:"_3-特征修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-特征修饰符"}},[_._v("#")]),_._v(" 3. 特征修饰符")]),_._v(" "),t("ul",[t("li",[_._v("final: 不可更改的可用于修饰 变量 属性 方法(子类不可重写) 类(Math)")]),_._v(" "),t("li",[_._v("static: 静态的,在加载类时加载(方法区,GC无法管理),可用于修饰类(内部类),方法,属性,程序块(static修饰的程序块在类加载是执行)")]),_._v(" "),t("li",[_._v("abstract: 用于修饰类和方法,抽象方法无结构体必须存在抽象类中等待子类继承实现具体逻辑")]),_._v(" "),t("li",[_._v("navtive: 修饰本地代码,执行体不可见")]),_._v(" "),t("li",[_._v("transient: 序列化")]),_._v(" "),t("li",[_._v("synchronized: 同步")]),_._v(" "),t("li",[_._v("volatile: 不稳定")])])])}),[],!1,null,null,null);v.default=i.exports}}]);